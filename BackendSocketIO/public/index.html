<!DOCTYPE html>
<html>
   <head>
      <title>FFT Demo</title>
      <meta charset="utf-8">
		<link rel="stylesheet" href="styles.css">
   </head>
   <body>
		<h1>FFT Demo</h1>
		<script src="/socket.io/socket.io.js"></script>

			<input type="checkbox" id="1" onclick="selectOnlyThis(this.id)" /> Unicast
			<input type="checkbox" id="2" onclick="selectOnlyThis(this.id)" /> Multicast

			<form>
				<input id="slider1" type="range" min="1" max="60" step="1" value="20" list="ticks" oninput="outputUpdate(this.value)"/>
			    FPS <output for=slider1 id="output">20</output>
			</form>
			<datalist id="ticks">
			    <option >1</option>
			    <option>10</option>
			    <option>20</option>
			    <option>30</option>
			    <option>40</option>
			    <option>50</option>
			    <option>60</option>
			</datalist>

			<!--<form>
				<input id="slider_fft_size" type="range" min="5" max="10" step="1" value="1" list="ticks_fft" oninput="fft_Size(this.value)"/>
			    FFT_Size <output for=slider_fft_size id="output_fft">32</output>
			</form>
			<datalist id="ticks_fft">
			    <option >32</option>
			    <option>64</option>
			    <option>128</option>
			    <option>256</option>
			    <option>512</option>
			    <option>1024</option>
			</datalist>-->

			<form>
				<input id="slider_numOfNodes" type="range" min="2" max="8" step="1" value="2" list="ticks_numOfNodes" oninput="outputnumOfNodes(this.value)"/>
			    Num of Nodes <output for=slider_numOfNodes id="output_numOfNodes">2</output>
			</form>
			<datalist id="ticks_numOfNodes">
			    <option>2</option>
			    <option>3</option>
			    <option>4</option>
			    <option>5</option>
			    <option>6</option>
			    <option>7</option>
			    <option>8</option>
			</datalist>


			<button onclick="fft_clicked()">FFT</button>

		<script>
		 	var socket = io.connect();

		 	var routing = [];
		 	// default settings_routing, unicast = true
		    for (var i = 1;i <= 2; i++) {
	        	document.getElementById(i).checked = false;
		        routing[i-1] = 0;
		    }
		 	document.getElementById("1").checked = true;
			routing[0] = 1;
			console.log("routing " + routing);
			socket.emit('settings_routing', { 'data': routing });


			var fft_power = 6;
			var numOfNodes = 2;
			var settings = [];

			var _array_node_colors = [];

			settings[0] = fft_power;
			settings[1] = numOfNodes;

			socket.emit('settings', { 'data': settings });



			function selectOnlyThis(id) {
			    for (var i = 1;i <= 2; i++){
			        document.getElementById(i).checked = false;
			        routing[i-1] = 0;
			    }
			    document.getElementById(id).checked = true;
			    routing[id-1] = 1;
			    console.log("routing " + routing);

			    socket.emit('settings_routing', { 'data': routing });
			}

			function fft_clicked() {
				webaudio();
			}

			function outputUpdate(num) {
				document.querySelector('#output').value = num;

				console.log("slider value " + num);
			}

			/*function fft_Size(num) {
				var power = Math.pow(2, num);
				document.querySelector('#output_fft').value = power;

				console.log("fft_slider value " + power);
			}*/

			function outputnumOfNodes(num) {
				document.querySelector('#output_numOfNodes').value = num;

				console.log("slider output_numOfNodes " + num);

				settings[1] = num;
				numOfNodes = num;

				socket.emit('settings', { 'data': settings });

			}

		</script>

		<p>Volume</p>
		<input id="volume" type="range" min="0" max="1" step="0.1" value="0.5"/>

		<canvas id="canvas" width="300" height="300" style="border:1px solid #000000;">Canvas to show content!</canvas>


		<script type="text/javascript">

		var canvas = document.getElementById('canvas');
		var ctx = canvas.getContext('2d');

		WIDTH = canvas.width;
		HEIGHT = canvas.height;

		function sleep(time, callback) {
		    var stop = new Date().getTime();
		    while(new Date().getTime() < stop + time) {
		        ;
		    }
		    callback();
		}

		function webaudio() {

		    var audioContext = new AudioContext();

		    console.log("audio is starting up ...");

		    var BUFF_SIZE_RENDERER = 16384;

		    var audioInput = null,
		    microphone_stream = null,
		    gain_node = null,
		    script_processor_node = null,
		    script_processor_analysis_node = null,
		    analyser_node = null;

		    if (!navigator.mediaDevices.getUserMedia)
		        navigator.mediaDevices.getUserMedia = navigator.mediaDevices.getUserMedia || navigator.mediaDevices.webkitGetUserMedia ||
		    navigator.mediaDevices.mozGetUserMedia || navigator.mediaDevices.msGetUserMedia;

		    if (navigator.mediaDevices.getUserMedia){

		        navigator.getUserMedia({audio:true}, 
		            function(stream) {
		            	start_microphone(stream);
		            },
		            function(e) {
		                alert('Error capturing audio.');
		            }
		            );

		    } else { alert('getUserMedia not supported in this browser.'); }

		    // ---

		    function show_some_data(given_typed_array, _array_spectral_color, label) {

		        var size_buffer = _array_spectral_color.length;
		        var index = 0;

				if (label === "frequency")
				{
		            ctx.fillStyle = 'rgb(200, 200, 200)';
		            ctx.fillRect(0, 0, WIDTH, HEIGHT);
		            //ctx.fillStyle = '#00CCFF';

		            var fft_bar_pos, fft_bar_width;
		            var fft_bar_pos = fft_bar_width = WIDTH/size_buffer;

					//console.log("size_buffer ", size_buffer);
					//console.log("fft_bar_width ", fft_bar_width);

		            for (var i = 0; i < size_buffer; i++) 
		            {
		                var x = i*fft_bar_pos;
		                //console.log("x ", x);
		                var fft_bar_height = -(given_typed_array[i]/2);
		                ctx.fillRect(x, HEIGHT, fft_bar_width, fft_bar_height);
		                ctx.fillStyle = '#'+_array_spectral_color[i].toString(16);
		            }
			    }
			    /*else if(label === "time") 
			    {
		            for (; index < num_row_to_display && index < size_buffer; index += 1) {

		                var curr_value_time = (given_typed_array[index] / 128) - 1.0;
		                console.log(curr_value_time);
		            }

		        }else {
		            throw new Error("ERROR - must pass time or frequency");
		        }*/
		    }

		    /*function process_microphone_buffer(event) {

		        var i, N, inp, microphone_output_buffer;

		        microphone_output_buffer = event.inputBuffer.getChannelData(0); // just mono - 1 channel for now
		    }*/

			function rgb2hex(red, green, blue) {
			        var rgb =   blue | (green << 8) | (red << 16);
			        //return '#' + (0x1000000 + rgb).toString(16).slice(1)
			        return (0x1000000 + rgb).toString(16).slice(1);
		  	}

			/**
			 * HSV color wheel crawling lights
			 */
			function hsv_crawling_lights(intensity, H)
			{
				// HSV in RGB
				//console.log("H ", H);
				var h=parseInt(H/60);
				//console.log("h ", h);
				
				var f=(H/60)-h;
				//console.log("f ", f);

				var i = intensity/255;
				var V = i; var S = 1;

				var p=(V*(1-S));
				var q=(V*(1-S*f));
				var t=(V*(1-S*(1-f)));

				if(h==0 || h==6)
				{ r=V; g=t; b=p; }
				if(h==1)
				{ r=q; g=V; b=p; }
				if(h==2)
				{ r=p; g=V; b=t; }
				if(h==3)
				{ r=p; g=q; b=V; }
				if(h==4)
				{ r=t; g=p; b=V; }
				if(h==5)
				{ r=V; g=p; b=q; }

				//console.log(rgb2hex(r*255,g*255,b*255));
				return rgb2hex(r*255,g*255,b*255);
				//return parseInt(rgb2hex(r*255,g*255,b*255), 16);
			}


		    // map color spectrum of visible light to frequency
		    function bindColor2Frequency(array_freq_domain, _array_spectral_color)
		    {
		    	var num_fft_elements = array_freq_domain.length;
		    	var array_freq_color = new Uint32Array(num_fft_elements);
				for (var i = 0; i < num_fft_elements; i++)
				{
					var r = ((_array_spectral_color[i] & 0xff0000) >> 16)/255.0;
					var g = ((_array_spectral_color[i] & 0x00ff00) >> 8)/255.0;
					var b = (_array_spectral_color[i] & 0x0000ff)/255.0;

					array_freq_color[i] = (r*array_freq_domain[i] << 16) + (g*array_freq_domain[i] << 8) + (b*array_freq_domain[i]);
				}

		    	//socket.send(array_freq_color);
		    }

		    function start_microphone(stream)
		    {

		        gain_node = audioContext.createGain();
		        gain_node.connect( audioContext.destination );

		        microphone_stream = audioContext.createMediaStreamSource(stream);
		        microphone_stream.connect(gain_node); 

		        script_processor_node = audioContext.createScriptProcessor(BUFF_SIZE_RENDERER, 1, 1);
		        //script_processor_node.onaudioprocess = process_microphone_buffer;

		        microphone_stream.connect(script_processor_node);

		        // --- enable volume control for output speakers

		        document.getElementById('volume').addEventListener('change', function() {

		            var curr_volume = this.value;
		            gain_node.gain.value = curr_volume;

		            //console.log("curr_volume ", curr_volume);
		        });

		        // --- setup FFT

		        script_processor_analysis_node = audioContext.createScriptProcessor(2048, 1, 1);
		        script_processor_analysis_node.connect(gain_node);

		        analyser_node = audioContext.createAnalyser();
		        analyser_node.smoothingTimeConstant = 0.4;
		        analyser_node.fftSize = Math.pow(2,fft_power);

		        microphone_stream.connect(analyser_node);

		        analyser_node.connect(script_processor_analysis_node);

		        var buffer_length = analyser_node.frequencyBinCount;

		        var array_freq_domain = new Uint8Array(buffer_length);

				var array_avg_color = [];

				var _array_spectral_color = [];

				// HSV step-size: 260 .. 0 .. -40 (360)
				var H = 250;
				var step_hsv = H/Math.pow(2,fft_power-1);
				//console.log("step_hsv ", step_hsv);

		        script_processor_analysis_node.onaudioprocess = function()
		        {
		        	sleep(1000/document.getElementById('slider1').value, function()
		        	{
			            // get the average for the first channel
			            analyser_node.getByteFrequencyData(array_freq_domain);
			            //analyser_node.getByteTimeDomainData(array_time_domain);

			            // draw the spectrogram
			            if (microphone_stream.playbackState == microphone_stream.PLAYING_STATE)
			            {
			            	for(var i=0; i<buffer_length; i++)
			            	{
		                		_array_spectral_color[i] = hsv_crawling_lights(array_freq_domain[i], step_hsv*i); // H = 260 .. 0
		                		//console.log("_array_spectral_color ", i, " ", _array_spectral_color[i]);
			            	}

        						
							//console.log("div hex: ", rgb2hex(255,0,0));

							//console.log("buffer_length ", buffer_length);

			            	for(var i=0; i<numOfNodes; i++)
							{
								console.log("numOfNodes ", numOfNodes);

								var r=0,g=0,b=0;
								for(var j=parseInt(i*(buffer_length/numOfNodes)); j<parseInt((i+1)*(buffer_length/numOfNodes)); j++)
								{
									//console.log("_array_spectral_color ", j, " ", _array_spectral_color[j]);

									//console.log("r_ ", (parseInt(_array_spectral_color[j], 16) >> 16) & 255);

									var int_p = parseInt(_array_spectral_color[j], 16);
									r += ((int_p >> 16) & 255);
									g += ((int_p >> 8) & 255);
									b += (int_p & 255);

									//console.log("r ", r, " ", "g ", g, " ", "b ", b);

									//array_avg_color[i] += _array_spectral_color[j];
								}
								
								r /= (buffer_length/numOfNodes);
								g /= (buffer_length/numOfNodes);
								b /= (buffer_length/numOfNodes);

								array_avg_color[i] = rgb2hex(r,g,b);
								console.log("array_avg_color ", i, " ", array_avg_color[i]);
							}



							if(routing[0])
								socket.send(array_avg_color);
							else if(routing[1])
								socket.send(array_avg_color);


			                //bindColor2Frequency(array_freq_domain, _array_spectral_color);

							show_some_data(array_freq_domain, _array_spectral_color, "frequency");

			                //socket.send(array_freq_domain);

			                //show_some_data(array_time_domain, 16, "time"); // store this to record to aggregate buffer/file
			                //draw(array_freq_domain);
			            }
		            });
		        };
		    }

		    /*function draw(array_freq_domain)
		    {
		        console.log("FREQUENCY: ", array_freq_domain.length);
		    }*/

		} //  webaudio_tooling_obj = function()

		</script>




   </body>
</html>